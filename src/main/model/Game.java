package model;

import exceptions.IllegalStartingLevelException;
import exceptions.IncorrectBoardSizeException;
import exceptions.NegativeLinesException;
import model.pieces.*;

import java.awt.*;
import java.util.*;
import java.util.List;

// Represents a Tetris game. This class is a "subject" in the observer design pattern.
// Observers are notified whenever a piece cannot move down.
public class Game extends Observable {
    // Number of types of Tetris pieces
    public static final int NUM_TETRIS_PIECES = 7;

    // Width and height of the board (measured in number of tiles)
    public static final int WIDTH = 10;
    public static final int HEIGHT = 20;

    // Points awarded for line clears
    // The values come from the table in the "Original BPS scoring system" section of https://tetris.wiki/Scoring
    public static final int SINGLE_POINTS = 40;
    public static final int DOUBLE_POINTS = 100;
    public static final int TRIPLE_POINTS = 300;
    public static final int TETRIS_POINTS = 1200;

    // The maximum starting level a player can start a game with.
    public static final int MAXIMUM_STARTING_LEVEL = 19;

    // A mapping from the random integers generated by the random number generator to PieceTypes.
    private static final Map<Integer, PieceType> RANDOM_INT_TO_PIECE_TYPE;

    private Random random;
    private Piece activePiece;
    private Piece nextPiece;
    private List<ArrayList<Boolean>> board;
    private int score;
    private int linesCleared;
    private int startingLevel;
    private boolean gameOver;

    // Initializes the RANDOM_INT_TO_PIECE_TYPE map
    static {
        RANDOM_INT_TO_PIECE_TYPE = new HashMap<Integer, PieceType>();
        RANDOM_INT_TO_PIECE_TYPE.put(0, PieceType.IPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(1, PieceType.JPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(2, PieceType.LPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(3, PieceType.OPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(4, PieceType.SPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(5, PieceType.TPIECE);
        RANDOM_INT_TO_PIECE_TYPE.put(6, PieceType.ZPIECE);
    }

    // Used with the random number generator that chooses which type of piece to make next.
    // Credit to https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html for the tutorial
    // on how to make enums.
    private enum PieceType {
        IPIECE, JPIECE, LPIECE, OPIECE, SPIECE, TPIECE, ZPIECE;
    }

    // EFFECTS: creates a new Tetris game, where the pieces are randomly generated with
    //          the given seed. The player starts at the given startingLevel.
    //          Randomly generates an active piece and a next piece, then spawns the
    //          active piece at the top of the board.
    //          Throws IllegalStartingLevelException if startingLevel < 0 or
    //          if startingLevel > MAXIMUM_STARTING_LEVEL.
    public Game(long seed, int startingLevel) throws IllegalStartingLevelException {
        // Note: this method has a "seed" argument just so we can test the Game class while controlling
        // the randomness of the tetromino generator. I got this idea from the following answer
        // on StackOverflow by the user Parappa: https://stackoverflow.com/a/88110/3335320

        if (startingLevel < 0 || startingLevel > MAXIMUM_STARTING_LEVEL) {
            throw new IllegalStartingLevelException();
        }

        this.startingLevel = startingLevel;
        startNewGame(seed);
    }

    // MODIFIES: this
    // EFFECTS: updates the state of the game.
    //          Moves the active piece down one row if there is space.
    //          Otherwise, if the game is not over, clears any filled rows and modifies points earned, lines
    //          cleared, and level accordingly. Then, begins dropping a new piece from the top of the board.
    //          If the game is over (because the player topped out), ends the game.
    //          Notifies observers if the active piece could not move down one row.
    //
    //          Note: if the game is already over, calling this method does nothing.
    public void update() {
        if (!gameOver) {
            boolean pieceMovedDown = activePiece.moveDown();
            if (!pieceMovedDown) {
                clearLines();
                activePiece = nextPiece;
                if (!addPieceToBoard(activePiece)) {
                    gameOver = true;
                }
                PieceType nextPieceType = RANDOM_INT_TO_PIECE_TYPE.get(random.nextInt(NUM_TETRIS_PIECES));
                nextPiece = makePiece(nextPieceType);

                super.setChanged();
                super.notifyObservers();
            }
        }
    }

    // MODIFIES: this
    // EFFECTS: sets the board of this game. Throws an IncorrectBoardSizeException if the
    //          board does not contain Game.HEIGHT arraylists, each of which contains Game.WIDTH booleans.
    public void setBoard(List<ArrayList<Boolean>> board) throws IncorrectBoardSizeException {
        if (board.size() != Game.HEIGHT) {
            throw new IncorrectBoardSizeException();
        }
        for (ArrayList<Boolean> row : board) {
            if (row.size() != Game.WIDTH) {
                throw new IncorrectBoardSizeException();
            }
        }
        this.board = board;
    }

    // EFFECTS: returns the board, represented as a list of arraylists of booleans
    //          The c'th element in the r'th arraylist is true if the cell at coordinates
    //          (c, r) is occupied by a tile, and false otherwise (where c and r are indexed
    //          starting from 0).
    public List<ArrayList<Boolean>> getBoard() {
        return board;
    }

    // EFFECTS: returns true if the board cell at coordinates (x, y) is occupied by a tile. The cell in the upper-left
    //          corner has coordinates (0, 0), and the x-coordinate increases as one travels to the right, while the
    //          y-coordinate increases as one travels down.
    //          Throws IndexOutOfBoundsException if the coordinates (x, y) do not represent a cell on the board.
    public boolean isCellOccupied(int x, int y) {
        return board.get(y).get(x);
    }

    // MODIFIES: this
    // EFFECTS: fills the cell at coordinates (x, y) on the board with a tile. The cell in the upper-left corner has
    //          coordinates (0, 0), and the x-coordinate increases as one travels to the right, while the y-coordinate
    //          increases as one travels down.
    //          Throws IndexOutOfBoundsException if the coordinates (x, y) do not represent a cell on the board.
    public void placeTileAt(int x, int y) {
        board.get(y).set(x, true);
    }

    // MODIFIES: this
    // EFFECTS: removes the tile at coordinates (x, y) on the board, if there is a tile there. Otherwise, do nothing.
    //          The cell in the upper-left corner has coordinates (0, 0), and the x-coordinate increases as one travels
    //          to the right, while the y-coordinate increases as one travels down.
    //          Throws IndexOutOfBoundsException if the coordinates (x, y) do not represent a cell on the board.
    public void removeTileAt(int x, int y) {
        board.get(y).set(x, false);
    }

    // EFFECTS: returns the active piece
    public Piece getActivePiece() {
        return activePiece;
    }

    // EFFECTS: returns the next piece
    public Piece getNextPiece() {
        return nextPiece;
    }

    // EFFECTS: returns the player's score
    public int getScore() {
        return score;
    }

    // EFFECTS: returns the number of lines cleared so far
    public int getLinesCleared() {
        return linesCleared;
    }

    // MODIFIES: this
    // EFFECTS: sets the lines cleared to linesCleared.
    //          Throws NegativeLinesException if linesCleared < 0.
    public void setLinesCleared(int linesCleared) throws NegativeLinesException {
        if (linesCleared < 0) {
            throw new NegativeLinesException();
        }
        this.linesCleared = linesCleared;
    }

    // EFFECTS: returns the current level of the game. The level increases with line clears according to the
    //          rules given at the bottom of the Details section at https://tetris.wiki/Tetris_(NES,_Nintendo)
    public int getLevel() {
        int firstLevelIncreaseLines = Math.min(10 * startingLevel + 10, Math.max(100, 10 * startingLevel - 50));

        int normalizedLinesCleared = linesCleared - firstLevelIncreaseLines + 10;
        if (normalizedLinesCleared < 0) {
            return startingLevel;
        } else {
            return startingLevel + normalizedLinesCleared / 10;
        }
    }

    // EFFECTS: returns true if the game is over, false otherwise
    public boolean isGameOver() {
        return gameOver;
    }

    // EFFECTS: returns a blank game board
    public static List<ArrayList<Boolean>> getBlankBoard() {
        List<ArrayList<Boolean>> blankBoard = new ArrayList<ArrayList<Boolean>>();

        for (int i = 0; i < Game.HEIGHT; i++) {
            ArrayList<Boolean> row = new ArrayList<Boolean>();
            for (int j = 0; j < Game.WIDTH; j++) {
                row.add(false);
            }
            blankBoard.add(row);
        }
        return blankBoard;
    }

    // MODIFIES: this
    // EFFECTS: Starts a new game. Pieces are randomly generated using the given seed.
    //          Randomly generates an active piece and a next piece. The active piece
    //          spawns at the top of the board.
    private void startNewGame(long seed) {
        random = new Random(seed);
        PieceType pieceType1 = RANDOM_INT_TO_PIECE_TYPE.get(random.nextInt(NUM_TETRIS_PIECES));
        activePiece = makePiece(pieceType1);

        PieceType pieceType2 = RANDOM_INT_TO_PIECE_TYPE.get(random.nextInt(NUM_TETRIS_PIECES));
        nextPiece = makePiece(pieceType2);
        board = getBlankBoard();
        score = 0;
        linesCleared = 0;
        gameOver = false;

        addPieceToBoard(activePiece);
    }

    // EFFECTS: returns a new piece in this game that corresponds to the given PieceType
    //          (for example, if pieceType == PieceType.IPIECE, then returns a new IPiece).
    private Piece makePiece(PieceType pieceType) {
        if (pieceType == PieceType.IPIECE) {
            return new IPiece(this);
        } else if (pieceType == PieceType.JPIECE) {
            return new JPiece(this);
        } else if (pieceType == PieceType.LPIECE) {
            return new LPiece(this);
        } else if (pieceType == PieceType.OPIECE) {
            return new OPiece(this);
        } else if (pieceType == PieceType.SPIECE) {
            return new SPiece(this);
        } else if (pieceType == PieceType.TPIECE) {
            return new TPiece(this);
        } else {
            return new ZPiece(this);
        }
    }

    // MODIFIES: this
    // EFFECTS: adds the given piece to the board. If the addition does not cause the piece to
    //          intersect with other tiles, returns true. If the piece intersects with other tiles on the
    //          board, returns false. In any case, the piece fills the cells that it occupies
    //          on the board (within the bounds of the board).
    private boolean addPieceToBoard(Piece piece) {
        boolean noIntersection = true;
        for (Point p : piece.getTileLocations()) {
            // The addPieceToBoard method is only called when spawning a new piece into the board.
            // The only reason a piece could fail to spawn is if it is forced to intersect
            // with a tile.
            if (board.get(p.y).get(p.x)) {
                noIntersection = false;
            }
            board.get(p.y).set(p.x, true);
        }
        return noIntersection;
    }

    // MODIFIES: this
    // EFFECTS: clears any filled rows and moves the tiles in above rows downward
    //          by the appropriate number of rows. In particular, if n rows below a particular
    //          row, R, are cleared, then R will be moved down n rows.
    //          Changes the number of lines cleared and the player's score accordingly.
    private void clearLines() {
        List<Integer> rowsCleared = getFilledRowsIndices();

        for (int i = 0; i < rowsCleared.size(); i++) {
            ArrayList<Boolean> blankRow = new ArrayList<Boolean>();
            for (int j = 0; j < Game.WIDTH; j++) {
                blankRow.add(false);
            }
            board.remove((int) rowsCleared.get(i));
            board.add(0, blankRow);
        }

        int numRowsCleared = rowsCleared.size();
        linesCleared += numRowsCleared;
        if (numRowsCleared == 1) {
            score += SINGLE_POINTS;
        } else if (numRowsCleared == 2) {
            score += DOUBLE_POINTS;
        } else if (numRowsCleared == 3) {
            score += TRIPLE_POINTS;
        } else if (numRowsCleared == 4) {
            score += TETRIS_POINTS;
        }
    }

    // EFFECTS: returns a list of indices of rows that are currently completely
    //          filled with tiles
    private List<Integer> getFilledRowsIndices() {
        List<Integer> rowsCleared = new ArrayList<Integer>();

        for (int i = 0; i < Game.HEIGHT; i++) {
            List<Boolean> row = board.get(i);
            boolean rowCompletelyFilled = true;
            for (Boolean cellOccupied : row) {
                if (!cellOccupied) {
                    rowCompletelyFilled = false;
                    break;
                }
            }
            if (rowCompletelyFilled) {
                rowsCleared.add(i);
            }
        }

        return rowsCleared;
    }
}
